import random

class BaechuLogicV2_8_Final:
    """
    [배추] 로직 v2.8 - 2026.01.25 최종 이식
    --------------------------------------------------
    - 모든 번호(보너스 포함 7수) 동등 지위 분석
    - 가변 구간 에너지 가중치 (1.0 ~ 2.0배) 자동 적용
    - 엄격 퇴출: 12회 내 5회 이상 출현수 자동 제거
    - '두 나물 오직' 및 '7-가죽나무 통합 로직' 상시 적용
    --------------------------------------------------
    """
    def __init__(self, logic_A_provider, logic_01_provider):
        self.logic_A = logic_A_provider
        self.logic_01 = logic_01_provider

    def generate_combinations(self, past_12_rounds_data, total_count=5):
        # 1. R1/R2 독립 바구니 추출 (각 20수)
        basket_R1_20 = self.logic_A.get_independent_analysis_20()
        basket_R2_20 = self.logic_01.get_independent_analysis_20()
        
        # 2. 12회차 빈도 및 구간 통계 계산 (보너스 포함 7수 전수 조사)
        hot_numbers = {}
        section_counts = {i: 0 for i in range(5)} # 0:1-9, 1:10-19, 2:20-29, 3:30-39, 4:40-45
        
        for round_data in past_12_rounds_data:
            for num in round_data:
                hot_numbers[num] = hot_numbers.get(num, 0) + 1
                s_idx = min((num-1)//10, 4)
                section_counts[s_idx] += 1

        # [엄격 퇴출 규칙] 12회 내 5회 이상 출현수 제거
        ban_list = [n for n, c in hot_numbers.items() if c >= 5]
        
        # 3. 가변 구간 에너지 가중치 산출 (평균 대비 침체 구간 보정)
        avg_hit = sum(section_counts.values()) / 5
        section_weights = {}
        for idx, count in section_counts.items():
            # (평균+1) / (해당구간출현+1) 공식을 통한 자동 가중치 (최대 2.0배)
            section_weights[idx] = max(1.0, min(2.0, (avg_hit + 1) / (count + 1)))

        # 4. 유효 풀 구성 및 점수 연산 (주관 배제)
        full_pool = list(set(basket_R1_20) | set(basket_R2_20))
        full_pool = [n for n in full_pool if n not in ban_list]
        
        pure_intersection = list(set(basket_R1_20).intersection(set(basket_R2_20)))
        
        scored_candidates = []
        for n in full_pool:
            # 수식 A: 미출현 에너지 (역수 비례)
            score = 1.0 / (hot_numbers.get(n, 0) + 1)
            
            # 수식 B: 구간 가중치 곱산 (10번대 등 침체 구간 점수 증폭)
            s_idx = min((n-1)//10, 4)
            score *= section_weights[s_idx]
            
            # 수식 C: 교집합 가산점 (통합 로직의 핵심)
            if n in pure_intersection:
                score += 0.5
                
            scored_candidates.append((n, score))
        
        # 5. 최종 압축 12수 확정 (점수 순 정렬)
        scored_candidates.sort(key=lambda x: x[1], reverse=True)
        final_12_core = [n for n, score in scored_candidates[:12]]
        
        # 6. 최종 5조합 생성
        combinations = []
        for i in range(total_count):
            if i == 0:
                # 1번 조합: 최상위 6수 (로직상 확률 극대화 조합)
                line = sorted(final_12_core[:6])
            else:
                # 2~5번 조합: 압축 12수 내 무작위 샘플링 및 확률적 보완
                line = random.sample(final_12_core, min(len(final_12_core), 4))
            
            while len(line) < 6:
                candidates = [n for n in full_pool if n not in line]
                if not candidates: break
                # 미출현 빈도 기반 가중치 추출
                weights = [1.0 / (hot_numbers.get(n, 0) + 1) for n in candidates]
                line.append(random.choices(candidates, weights=weights, k=1)[0])
            
            combinations.append(sorted(line))
            
        return combinations, final_12_core, ban_list
